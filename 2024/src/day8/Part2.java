package day8;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class Part2 {

  /*
   * https://adventofcode.com/2024/day/8
   */
  public static void main(String[] args) throws IOException {

    // Read in the data
    final String inputFilename = args[0];
    final List<String> input = Files.readAllLines(Paths.get(inputFilename));

    // the input contains a grid, with the following attributes:
    // 1. a . represents an empty space
    // 2. any lowercase, upper case character, or a single digit number represents an antenna
    final Grid grid = new Grid(input);
    System.out.println(grid);

    // find the 'pairs' of antennas in the grid, defined as:
    // for two antennas of the same frequency, they form a pair
    // one antenna can be in multiple pairs
    // a list containing each pair to process
    final List<CoordinatePair> pairs = new ArrayList<>();
    for (int i = 0; i < grid.getGrid().length; i++) {
      for (int j = 0; j < grid.getGrid()[i].length; j++) {
        final char contents = grid.getGrid()[i][j].getFrequency();
        //System.out.println("Finding pairs for: " + contents + " at (" + i + "," + j + ")");
        if (Character.isLetter(contents) || Character.isDigit(contents)) {
          //System.out.println("Finding pairs for: " + contents + " at (" + i + "," + j + ")");
          // find any other GridBlocks that this one forms a pair with
          // only scan forwards from this block
          for (int k = i; k < grid.getGrid().length; k++) {
            int l = i == k ? (j + 1) : 0;
            while (l < grid.getGrid()[k].length) {
              final char otherContents = grid.getGrid()[k][l].getFrequency();
              if (contents == otherContents) {
                // we have a pair
                //System.out.println("Pair found: " + contents + " at (" + i + "," + j + ") and (" + k + "," + l + ")");
                pairs.add(new CoordinatePair(contents, i, j, k, l));
              }
              l++;
            }
          }
        }
      }
    }

    // print out the pairs
//    for (CoordinatePair pair : pairs) {
//      System.out.println(pair);
//    }

    // given how we scanned, we shouldn't actually end up with any duplicate pairs with the points reversed
    // now we need to calculate the antinodes generated by each pair, defined as:
    // an antinode occurs at any point that is perfectly in line with two antennas of the same frequency - but only when one of the antennas is twice as far away as the other. This means that for any pair of antennas with the same frequency, there are two antinodes, one on either side of them.
    // we need to iterate the list of pairs, then determine the two antinodes each pair produces, and update the relevant field in the GridBlock, in the main grid

    for (CoordinatePair pair : pairs) {
      //System.out.println("Processing pair antinodes for pair: " + pair);
      final int x1 = pair.x1();
      final int y1 = pair.y1();
      final int x2 = pair.x2();
      final int y2 = pair.y2();
      final int xDiff = Math.abs(x1 - x2);
      final int yDiff = Math.abs(y1 - y2);

      // in this part, every antenna will also have an antinode at the same position
      grid.getGrid()[x1][y1].setHasAntinode(true);
      grid.getGrid()[x2][y2].setHasAntinode(true);

      if (xDiff == 0) {
        // the pair is vertical
        System.out.println("Pair is vertical");
        break;
      } else if (yDiff == 0) {
        // the pair is horizontal
        System.out.println("Pair is horizontal");
        break;
      } else {
        // the pair is diagonal
        //System.out.println("Pair is diagonal");

        // as above, but this time in the diagonal direction
        // we need to determine which direction the pair is in, to know if we should + or - from the starting x and y positions
        // determine if the other node in the pair is diagonally down left or down right from the first node
        int antiNodeAx;
        int antiNodeAy;
        int antiNodeBx;
        int antiNodeBy;

        // down right
        if (x1 < x2 && y1 < y2) {
          // the first two antinodes on either side of the pair
          antiNodeAx = x1 - xDiff;
          antiNodeAy = y1 - yDiff;
          if (isAntiNodeWithinGrid(antiNodeAy, grid, antiNodeAx)) {
            System.out.println("Visible antinode found at: (" + antiNodeAx + "," + antiNodeAy + ")");
            grid.getGrid()[antiNodeAx][antiNodeAy].setHasAntinode(true);
          }

          antiNodeBx = x2 + xDiff;
          antiNodeBy = y2 + yDiff;
          // if antinode B is within the grid, then update the grid
          if (isAntiNodeWithinGrid(antiNodeBy, grid, antiNodeBx)) {
            System.out.println("Visible antinode found at: (" + antiNodeBx + "," + antiNodeBy + ")");
            grid.getGrid()[antiNodeBx][antiNodeBy].setHasAntinode(true);
          }

          // we now need to keep going, down right and up left, to find the other antinodes
          // the next two antinodes on either side of the pair
          // for loop going from Ax Ay up left until the edge of the grid
          int antiNodeXStart = antiNodeAx - xDiff;
          int antiNodeYStart = antiNodeAy - yDiff;
          // move up left to the top of the grid
          while (antiNodeXStart >= 0 && antiNodeYStart >= 0) {
            System.out.println("Found resonant antinode at: (" + antiNodeXStart + "," + antiNodeYStart + ")");
            grid.getGrid()[antiNodeXStart][antiNodeYStart].setHasAntinode(true);
            antiNodeXStart -= xDiff;
            antiNodeYStart -= yDiff;
          }

          // for loop going from Bx By down right until the edge of the grid
          antiNodeXStart = antiNodeBx + xDiff;
          antiNodeYStart = antiNodeBy + yDiff;
          // move down right to the bottom of the grid
          while (antiNodeXStart < grid.getGrid().length && antiNodeYStart < grid.getGrid()[0].length) {
            System.out.println("Found resonant antinode at: (" + antiNodeXStart + "," + antiNodeYStart + ")");
            grid.getGrid()[antiNodeXStart][antiNodeYStart].setHasAntinode(true);
            antiNodeXStart += xDiff;
            antiNodeYStart += yDiff;
          }
        } else if (x1 < x2 && y1 > y2) {
          // up right
          // System.out.println("Pair is up right");
          antiNodeAx = x1 - xDiff;
          antiNodeAy = y1 + yDiff;
          if (isAntiNodeWithinGrid(antiNodeAy, grid, antiNodeAx)) {
            System.out.println("Visible antinode found at: (" + antiNodeAx + "," + antiNodeAy + ")");
            grid.getGrid()[antiNodeAx][antiNodeAy].setHasAntinode(true);
          }

          antiNodeBx = x2 + xDiff;
          antiNodeBy = y2 - yDiff;
          if (isAntiNodeWithinGrid(antiNodeBy, grid, antiNodeBx)) {
            System.out.println("Visible antinode found at: (" + antiNodeBx + "," + antiNodeBy + ")");
            grid.getGrid()[antiNodeBx][antiNodeBy].setHasAntinode(true);
          }

          // we now need to keep going, down left and up right, to find the other antinodes
          // the next two antinodes on either side of the pair
          int antiNodeXStart = antiNodeAx - xDiff;
          int antiNodeYStart = antiNodeAy + yDiff;
          // move up right to the top of the grid
          while (antiNodeXStart >= 0 && antiNodeYStart < grid.getGrid()[0].length) {
            System.out.println("Found resonant antinode at: (" + antiNodeXStart + "," + antiNodeYStart + ")");
            grid.getGrid()[antiNodeXStart][antiNodeYStart].setHasAntinode(true);
            antiNodeXStart -= xDiff;
            antiNodeYStart += yDiff;
          }

          antiNodeXStart = antiNodeBx + xDiff;
          antiNodeYStart = antiNodeBy - yDiff;
          // move down left to the bottom of the grid
          while (antiNodeXStart < grid.getGrid().length && antiNodeYStart >= 0) {
            System.out.println("Found resonant antinode at: (" + antiNodeXStart + "," + antiNodeYStart + ")");
            grid.getGrid()[antiNodeXStart][antiNodeYStart].setHasAntinode(true);
            antiNodeXStart += xDiff;
            antiNodeYStart -= yDiff;
          }

        } else if (x1 > x2 && y1 < y2) {
          // down left
          System.out.println("Pair is down left");
          break;
        } else {
          // up left
          System.out.println("Pair is up left");
          break;
        }
      }
    }

    System.out.println(grid);
    System.out.println("There are " + grid.getAntiNodeCount() + " antinodes in the grid");
  }

  private static boolean isAntiNodeWithinGrid(int nodeY, Grid grid, int nodeX) {
    //System.out.println("Checking if antinode is within grid: " + nodeX + "," + nodeY);
    //System.out.println("Grid dimensions: " + grid.getGrid().length + "," + grid.getGrid()[0].length);
    return nodeY >= 0 && nodeY < grid.getGrid()[0].length && nodeX >= 0 && nodeX < grid.getGrid().length;
  }

}